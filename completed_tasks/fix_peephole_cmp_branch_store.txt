Task: Fix peephole compare-and-branch fusion incorrectly NOP'ing stack stores
Status: Complete
Branch: master

Problem:
The peephole optimizer's fuse_compare_and_branch function NOP'd StoreRbp
instructions when fusing a compare+setCC+test+branch sequence. This eliminated
stores of comparison results to stack slots, which were needed by other basic
blocks that referenced the same value (via GVN/copy propagation).

Root cause:
In musl libc's try_avail() function, GVN replaces a redundant if(!m) check
with a reference to the first check's comparison result. The first check's
boolean value is stored to a stack slot, but peephole fusion NOP'd that store,
leaving the slot uninitialized. The second block reads garbage from the
uninitialized slot, causing malloc to return overlapping memory addresses.

Fix:
Skip peephole compare-branch fusion when a StoreRbp instruction exists between
the setCC and testq instructions, since the store may be needed by other blocks.

Files changed:
- src/backend/x86/codegen/peephole.rs: Skip fusion when StoreRbp present
- tests/peephole-cmp-branch-store-preservation/: Regression test
