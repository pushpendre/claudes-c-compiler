Fix address-taken function parameter aliasing with local variable copies

Bug: When a function parameter has its address taken (e.g., &ptr passed to
a function), and another local variable was initialized from that parameter
(e.g., const char *hdr = ptr), the compiler incorrectly aliases hdr and ptr
to the same stack slot. When the parameter is modified via the pointer, the
local copy also changes, violating C semantics.

Example:
  void test(const char *ptr) {
      const char *hdr = ptr;  // should be independent copy
      modify(&ptr);           // modifies ptr through pointer
      // hdr should still have original value, but has new value
  }

Root cause: mem2reg or IR lowering treats the copy `hdr = ptr` as a direct
alias to ptr's alloca instead of creating a separate value.

Affects: yyjson (test_json_pointer), likely other projects using this pattern.
Status: in_progress
