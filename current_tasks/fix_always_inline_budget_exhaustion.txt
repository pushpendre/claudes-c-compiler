Task: Fix always_inline budget exhaustion causing kernel section mismatch errors
Status: in_progress

Problem:
The inline pass has a budget limit (MAX_ALWAYS_INLINE_BUDGET_PER_CALLER = 2000 instructions)
that can prevent __attribute__((always_inline)) functions from being inlined into large callers.
When this happens, the always_inline function is emitted as a standalone function in .text,
but it may reference data in .init.rodata (via __initconst), creating a cross-section reference
that modpost flags as a section mismatch error.

This causes the Linux x86 kernel build to fail at the MODPOST step with:
  ERROR: modpost: Section mismatches detected.
  WARNING: vmlinux: section mismatch: intel_pmu_init_hybrid (section: .text)
    -> intel_hybrid_pmu_type_map (section: .init.rodata)

Root cause:
In inline.rs, line 267: `if callee_inst_count > effective_budget { continue; }`
This check applies even to always_inline callees, causing them to be skipped when
the always_inline budget (2000) is exhausted.

Fix:
Remove the budget check for always_inline callees. Per C semantics (and GCC/Clang behavior),
__attribute__((always_inline)) functions MUST always be inlined at their call sites.
Budget limits should only apply to normal (non-always_inline) inlining.
