Fix ARM f128 register cache invalidation after __extenddftf2 calls

Bug: The ARM backend's f128_load_operand_and_extend() calls operand_to_x0()
followed by bl __extenddftf2, but does NOT invalidate the register cache
afterward. Since __extenddftf2 is a function call that clobbers x0, the
next operand_to_x0() call for the same value will hit the stale cache and
skip the load, using garbage from x0.

This causes complex long double division to produce inf/nan when one operand
is a global variable. The denom = c*c + d*d computation gets the wrong values
for c and d because the second load of c/d reuses the stale x0.

Fix: Add reg_cache.invalidate_all() after bl __extenddftf2 in
f128_load_operand_and_extend.

Status: in_progress
