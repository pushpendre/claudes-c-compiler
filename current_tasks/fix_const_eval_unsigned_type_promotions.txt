Task: Fix constant expression evaluation for unsigned type promotions

Status: In progress

Problem:
Two bugs in compile-time constant expression evaluation cause incorrect values
in global initializers involving unsigned integer types:

1. coerce_to_with_src() sign-extends unsigned values when widening to larger types.
   E.g., (unsigned)-8 stored as IrConst::I32(-8) gets sign-extended to I64(-8)
   instead of being zero-extended to I64(4294967288).

2. eval_const_binop() only considers the LHS operand type for determining result
   width, ignoring the RHS type. This violates C's usual arithmetic conversions
   (C11 6.3.1.8). E.g., (-100) - (unsigned_long_long_value << 2) computes as
   32-bit instead of 64-bit because -100 is int.

Fix:
- coerce_to_with_src: mask to source type width before widening when source is unsigned
- eval_const_binop: accept both operand types and use max width + proper signedness

Files changed:
- src/ir/ir.rs (coerce_to_with_src)
- src/frontend/sema/const_eval.rs (eval_const_binop)
- src/ir/lowering/const_eval.rs (eval_const_binop)
