Task: Fix i686 F64 (double) support
Status: completed
Started: 2026-01-28
Completed: 2026-01-28

Description:
The i686 backend's F64 (double) handling was fundamentally broken because the
accumulator model uses eax (32-bit) but F64 needs 64 bits.

Changes made (all in src/backend/i686/codegen/codegen.rs):
- emit_load/emit_store: Extended to handle F64 like I64/U64 using eax:edx pairs
- emit_load_with_const_offset/emit_store_with_const_offset: New overrides for
  GEP-folded operations that bypass the normal load/store paths
- emit_float_binop: New override using x87 FPU (faddp, fsubp, fmulp, fdivp) for F64
- emit_float_cmp: Rewritten to use x87 fucomip for F64, SSE ucomiss for F32
- emit_cast: New override handling all F64-involved type conversions
- emit_unaryop: New override for F64 negation using x87 fchs
- emit_return: Extended to handle F64 returns via x87 fldl
- emit_call_store_result: Fixed F64 return from calls (fstpl to slot)
- emit_store_params: Fixed F64 parameter loading (8 bytes instead of 4)
- emit_param_ref: Fixed F64 parameter references (8 bytes)
- emit_load_acc_pair: Added F64 constant and Zero handling
- emit_f64_load_to_x87/emit_f64_store_from_x87: New helper methods

Results:
- i686 tests: 59.8% (16,269) -> 69.5% (18,918) = +2,649 tests passing
- No regressions on x86, ARM, RISC-V backends
- x86 kernel: PASS
- i686 projects: libjpeg PASS, libuv PASS
