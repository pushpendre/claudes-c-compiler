Task: Fix RISC-V F128 (long double) binary operation precision loss
Status: in_progress
Started: 2026-01-27

Problem:
The RISC-V F128 binary operation codegen (emit_f128_binop_softfloat) was using
f64 approximations for operands instead of full-precision f128 values. This
caused incorrect results when operands were loaded from stack slots that held
16-byte f128 data -- the code would load the f128 low half as if it were an f64
bit pattern, producing garbage values.

Fix:
Override emit_float_binop in the RISC-V backend to handle F128 operations
by loading full-precision f128 operands via emit_f128_operand_to_a0_a1()
instead of going through the default operand_to_t0() path that treats
slot data as f64 approximations. This matches the approach already used
by the ARM backend (emit_f128_binop_softfloat_full).

Files changed:
- src/backend/riscv/codegen/codegen.rs (add emit_float_binop override)

Impact: Fixes 6+ RISC-V test failures involving long double arithmetic.
