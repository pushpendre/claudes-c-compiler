HIGH PRIORITY: i686 Boot Code Size Reduction (Linux kernel "Setup too big" fix)

Problem:
The Linux kernel's 16-bit boot code (arch/x86/boot/) must fit in 32KB.
GCC with -Os -mregparm=3 -fomit-frame-pointer produces ~20KB.
CCC currently produces ~65KB, exceeding the limit by 2x.

Root Cause Analysis (comparing CCC vs GCC for tty.c):
- CCC: 394 lines of assembly, ~1300 bytes text
- GCC: 179 lines of assembly, ~400 bytes text
- CCC is ~3x larger per file

Key improvements needed (in priority order):

1. i686 Peephole Optimizer (HIGHEST IMPACT, ~30-40% code reduction)
   Port key passes from the x86-64 peephole to i686:
   - Dead store elimination: movl %eax, N(%ebp) followed by movl %X, N(%ebp)
   - Store-load forwarding: movl %eax, N(%ebp) + movl N(%ebp), %eax -> eliminate second
   - Self-move elimination: movl %eax, %eax -> nop
   - Copy propagation: movl %eax, %ebx + movl %ebx, %eax -> eliminate second
   - Compare-branch fusion
   The x86-64 peephole infrastructure is well-tested and could be adapted.

2. -fomit-frame-pointer for i686 (~10-15% code reduction)
   Replace EBP-relative addressing with ESP-relative for all slot accesses.
   Challenges:
   - ESP changes during function calls (subl/addl around calls)
   - Need to track ESP offset at each instruction
   - All slot references need offset adjustment
   - Frees EBP as a general-purpose register (4th allocatable reg!)
   GCC uses ESP-relative extensively for -Os code.

3. Register allocation improvements (~10-20% code reduction)
   Currently only 3 callee-saved regs are allocatable (ebx, esi, edi).
   With frame pointer omission, ebp becomes available (4th reg).
   Better register allocation reduces spills to stack.

4. -Os specific optimizations
   - Prefer shorter instruction encodings (e.g., xorl %eax, %eax vs movl $0, %eax)
   - More aggressive inlining threshold reduction
   - Tail call optimization for leaf functions

Status:
- -mregparm=3 has been implemented
- i686 peephole optimizer has been implemented (Phase 1 done):
  - Store/load forwarding, self-move elimination, dead store elimination,
    compare-branch fusion (enhanced with store/load pair skipping),
    memory operand folding, branch inversion, reverse move elimination,
    never-read store elimination
  - Strength reduction: addl $1 → incl, subl $1 → decl, movl $0 → xorl
  - Redundant movsbl elimination
- Current boot size: ~63KB (target: 32KB)
- Remaining gap requires items 2-4 above (frame pointer omission, better
  register allocation, -Os specific optimizations)
