HIGH PRIORITY: Expand sema to produce a typed AST, reducing lowering responsibilities

Current state (after Steps 1-4 complete):
The sema pass collects type information (typedefs, struct layouts, enum constants,
function signatures), has ExprTypeChecker for CType inference, and now annotates
every analyzable expression with its CType via an ExprTypeMap. The lowerer receives
this map and uses it as a fallback in get_expr_ctype(), so sema's type inference
is consulted before the lowerer falls back to its own inference. It does NOT yet:
- Reject type errors with diagnostics
- Replace the lowerer's expr_types.rs entirely (lowerer still needs its own
  get_expr_ctype_lowerer for lowering-specific state like locals/globals)
- Unify constant expression evaluation between sema and lowerer

The lowerer (ir/lowering/) is ~18K lines and handles both type inference AND IR
emission. Key type-inference code that should move to sema:

1. Expression type inference (expr_types.rs, ~1200 lines)
   - get_expr_type(): determines IrType of any expression
   - get_expr_ctype(): determines CType of any expression using lowering state
   - struct_value_size(): checks if expression produces struct value
   The lowerer's version needs locals/globals; sema's ExprTypeChecker uses
   SymbolTable instead. As sema's type tracking becomes complete, the lowerer
   can delegate more to sema.

2. Constant expression evaluation (const_eval.rs, 969 lines)
   Both sema and lowering have const_eval. Sema's is simpler (for enum values,
   array dimensions). Lowering's handles more cases (global initializers,
   sizeof of complex types). These should be unified.

3. Type conversion duplication (DONE - unified via TypeConvertContext trait)
   The type_spec_to_ctype dispatch was unified into type_builder.rs.

4. C type arithmetic (DONE - moved to CType methods)
   usual_arithmetic_conversion(), integer_rank(), is_unsigned() are now CType
   methods in common/types.rs, shared by both sema and lowering.

5. Declaration analysis (lowering.rs analyze_declaration, ~200 lines)
   Computes DeclAnalysis from type specifiers. This is type analysis, not IR.

Incremental approach:
Step 1: (DONE) Move TypeContext to sema/type_context.rs
Step 2: (DONE) Add ExprTypeChecker in sema/type_checker.rs with infer_expr_ctype()
        - CType arithmetic (usual_arithmetic_conversion etc.) moved to CType methods
        - ExprTypeChecker uses SymbolTable + TypeContext + FunctionInfo
        - Sema now resolves typeof(expr) via ExprTypeChecker
Step 2.5: (DONE) Pass sema function signatures to lowerer
        - Lowerer receives FxHashMap<String, FunctionInfo> from SemaResult
        - Pre-populates known_functions from sema's function map
        - Uses sema's return CType as source-of-truth in register_function_meta
        - Falls back to sema function info in get_expr_ctype, get_call_return_type,
          get_function_return_ctype for function return type resolution
        - Eliminates redundant type_spec_to_ctype calls in register_function_meta
Step 3: (DONE) Have sema annotate expressions with CTypes during its walk
        - Added ExprTypeMap (FxHashMap<usize, CType>) to SemaResult
        - Uses raw pointer address of Expr nodes as stable key (AST is immutable)
        - Sema's analyze_expr() calls ExprTypeChecker::infer_expr_ctype() for each
          expression and stores results in expr_types map
        - ExprTypeMap type exported from sema module
Step 4: (DONE) Have lowerer consume sema's type annotations instead of re-computing
        - Lowerer receives ExprTypeMap in with_type_context() constructor
        - get_expr_ctype() now tries lowerer-specific inference first, then falls
          back to sema's pre-computed annotations via lookup_sema_expr_type()
        - Original logic moved to get_expr_ctype_lowerer() internal method
        - Zero regressions across all three backends (x86, ARM, RISC-V)
Step 5: Move constant evaluation to sema (unify the two const_eval implementations)
Step 6: Add actual type error diagnostics in sema
Step 7: Simplify lowering to assume types are correct

Benefits:
- Type errors become diagnostics instead of IR lowering panics
- Lowering shrinks from ~18K to ~12K lines
- Clearer module boundary: sema validates, lowering emits
- Enables future type-system features (generics, better error messages)

Key files:
- src/frontend/sema/sema.rs (current sema pass)
- src/frontend/sema/type_context.rs (TypeContext, in sema)
- src/frontend/sema/type_checker.rs (ExprTypeChecker for CType inference)
- src/common/types.rs (CType methods: usual_arithmetic_conversion, integer_rank, etc.)
- src/ir/lowering/expr_types.rs (~1200 lines of type inference, partially shared now)
- src/ir/lowering/const_eval.rs (969 lines of const eval to unify)
- src/ir/lowering/lowering.rs (analyze_declaration to move; now consumes sema functions)
