Reduce Stack Frame Size for PostgreSQL plpgsql Recursion
========================================================
Date: 2026-01-26

PROBLEM
-------
PostgreSQL's plpgsql test "recursion_test(4,3)" fails with "stack depth
limit exceeded" at max_stack_depth=2048kB. The issue is that our compiled
code uses significantly larger stack frames than GCC, causing the cumulative
stack depth to exceed the limit in deeply nested call chains.

Concrete comparison for plpgsql_exec_function (the key recursive function):
  - Our compiler: 1392 bytes (sub $0x570, %rsp) + 40 bytes callee-saved = 1432 bytes
  - GCC -O0:      328 bytes (sub $0x148, %rsp) + 48 bytes callee-saved = 376 bytes
  - Our frame is 3.8x larger than GCC's

ROOT CAUSES
-----------
1. Every SSA temporary gets an 8-byte stack slot, even for i32/i16/i8 types.
   A simple `int a = b + c` generates 3-4 separate 8-byte slots (for the
   loads, the add result, and the store), while GCC uses 4-byte movl
   instructions with tighter packing.

2. Intermediate SSA values from expression evaluation each get their own
   slot. For `a[i].field`, we generate separate slots for: load a, load i,
   GEP computation, field offset GEP, and the load result. GCC computes
   these in-register without spilling.

3. The codegen stores every value to the stack via movq even when the next
   instruction immediately loads it back. The peephole optimizer removes
   the redundant store/load instructions but the SLOT is still allocated.

POTENTIAL FIXES (ordered by impact and feasibility)
---------------------------------------------------
1. Use 4-byte slots for i32 and smaller types (HIGH IMPACT, MEDIUM EFFORT)
   - Change slot_size computation in calculate_stack_space_common
   - Requires changes to store/load paths in all 3 backends to use movl
   - Could reduce frame sizes by ~40% for typical C code
   - Risk: alignment and zero-extension issues need careful handling

2. Skip slot allocation for single-use values consumed immediately (HIGH IMPACT)
   - If a value is defined at instruction N and only used at instruction N+1,
     it doesn't need a stack slot (the value stays in %rax between instructions)
   - Requires tracking "immediate consumers" during stack space calculation
   - Could eliminate 30-50% of slots in typical functions

3. Improve register allocation with caller-saved registers (HIGHEST IMPACT)
   - Currently we only use callee-saved registers (rbx, r12-r15)
   - Adding caller-saved registers (rcx, rdx, rsi, rdi, r8-r11) for values
     that don't cross calls would eliminate most stack slots in leaf functions
     and basic blocks between calls
   - This is the biggest win but also the most complex change

4. Increase PostgreSQL's max_stack_depth at startup (WORKAROUND)
   - We could have our compiler define __attribute__((constructor)) to set
     max_stack_depth higher, but this is fragile and undesirable

METRICS
-------
If we implement fix #1 (4-byte slots), the plpgsql_exec_function frame
would shrink from ~1392 to ~950 bytes (estimated). Combined with the
callee-saved optimization already done, this might bring it close enough
to GCC's frame size to pass the recursion test.

If we implement fix #2 (skip immediate-use slots), we could save another
200-300 bytes per function.

Fix #3 (caller-saved regs) is the long-term solution that would make our
code competitive with GCC -O1 for stack usage.
